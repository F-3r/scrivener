{"name":"Scrivener","body":"Validation frontend for models\r\n==============================\r\n\r\nScrivener removes the validation responsibility from models and acts as a\r\nfilter for whitelisted attributes.\r\n\r\nA model may expose different APIs to satisfy different purposes. For example,\r\nthe set of validations for a User in a Sign up process may not be the same\r\nas the one exposed to an Admin when editing a user profile. While you want\r\nthe User to provide an email, a password and a password confirmation, you\r\nprobably don't want the admin to mess with those attributes at all.\r\n\r\nIn a wizard, different model states ask for different validations, and a single\r\nset of validations for the whole process is not the best solution.\r\n\r\nScrivener is Bureaucrat's little brother. It draws all the inspiration from it\r\nand its features are a subset of Bureaucrat's. For a more robust and tested\r\nsolution, please [check it](https://github.com/tizoc/bureaucrat).\r\n\r\nThis library exists to satify the need of extracting Ohm's validations for\r\nreuse in other scenarios. By doing this, all projects using `Ohm::Validations`\r\nwill be able to profit from extra assertions such as those provided by\r\n[ohm-contrib](https://github.com/cyx/ohm-contrib).\r\n\r\nUsage\r\n-----\r\n\r\nUsing Scrivener feels very natural no matter what underlying model you are\r\nusing. As it provides its own validation and whitelisting features, you can\r\nchoose to ignore the ones that come bundled with ORMs.\r\n\r\nThis short example illustrates how to move the validation and whitelisting\r\nresponsibilities away from the model and into Scrivener:\r\n\r\n```ruby\r\n# We use Sequel::Model in this example, but it applies to other ORMs such\r\n# as Ohm or ActiveRecord.\r\nclass Article < Sequel::Model\r\n\r\n  # Whitelist for mass assigned attributes.\r\n  set_allowed_columns :title, :body, :state\r\n\r\n  # Validations for all contexts.\r\n  def validate\r\n    validates_presence :title\r\n    validates_presence :body\r\n    validates_presence :state\r\n  end\r\nend\r\n\r\ntitle = \"Bartleby, the Scrivener\"\r\nbody  = \"I am a rather elderly man...\"\r\n\r\n# When using the model...\r\narticle = Article.new(title: title, body: body)\r\n\r\narticle.valid?            #=> false\r\narticle.errors.on(:state) #=> [\"cannot be empty\"]\r\n```\r\n\r\nOf course, what you would do instead is declare `:title` and `:body` as allowed\r\ncolumns, then assign `:state` using the attribute accessor. The reason for this\r\nexample is to show how you need to work around the fact that there's a single\r\ndeclaration for allowed columns and validations, which in many cases is a great\r\nfeature and in others is a minor obstacle.\r\n\r\nNow see what happens with Scrivener:\r\n\r\n```ruby\r\n# Now the model has no validations or whitelists. It may still have schema\r\n# constraints, which is a good practice to enforce data integrity.\r\nclass Article < Sequel::Model\r\nend\r\n\r\n# The attribute accessors are the only fields that will be set. If more\r\n# fields are sent when using mass assignment, a NoMethodError exception is\r\n# raised.\r\n#\r\n# Note how in this example we don't accept the status attribute.\r\nclass Edit < Scrivener\r\n  attr_accessor :title\r\n  attr_accessor :body\r\n\r\n  def validate\r\n    assert_present :title\r\n    assert_present :body\r\n  end\r\nend\r\n\r\nedit = Edit.new(title: title, body: body)\r\nedit.valid?               #=> true\r\n\r\narticle = Article.new(edit.attributes)\r\narticle.save\r\n\r\n# And now we only ask for the status.\r\nclass Publish < Scrivener\r\n  attr_accessor :status\r\n\r\n  def validate\r\n    assert_format :status, /^(published|draft)$/\r\n  end\r\nend\r\n\r\npublish = Publish.new(status: \"published\")\r\npublish.valid?            #=> true\r\n\r\narticle.update_attributes(publish.attributes)\r\n\r\n# If we try to change other fields...\r\npublish = Publish.new(status: \"published\", title: \"foo\")\r\n#=> NoMethodError: undefined method `title=' for #<Publish...>\r\n```\r\n\r\nIt's important to note that using Scrivener implies a greater risk than using\r\nthe model validations. Having a central repository of mass assignable\r\nattributes and validations is more secure in most scenarios.\r\n\r\nAssertions\r\n-----------\r\n\r\nScrivener ships with some basic assertions. The following is a brief description\r\nfor each of them:\r\n\r\n### assert\r\n\r\nThe `assert` method is used by all the other assertions. It pushes the\r\nsecond parameter to the list of errors if the first parameter evaluates\r\nto false.\r\n\r\n``` ruby\r\ndef assert(value, error)\r\n   value or errors[error.first].push(error.last) && false\r\nend\r\n```\r\n\r\n### assert_present\r\n\r\nChecks that the given field is not nil or empty. The error code for this\r\nassertion is `:not_present`.\r\n\r\n### assert_format\r\n\r\nChecks that the given field matches the provided regular expression.\r\nThe error code for this assertion is `:format`.\r\n\r\n### assert_numeric\r\n\r\nChecks that the given field holds a number as a Fixnum or as a string\r\nrepresentation. The error code for this assertion is `:not_numeric`.\r\n\r\n### assert_url\r\n\r\nProvides a pretty general URL regular expression match. An important\r\npoint to make is that this assumes that the URL should start with\r\n`http://` or `https://`. The error code for this assertion is\r\n`:not_url`.\r\n\r\n### assert_email\r\n\r\nIn this current day and age, almost all web applications need to\r\nvalidate an email address. This pretty much matches 99% of the emails\r\nout there. The error code for this assertion is `:not_email`.\r\n\r\n### assert_member\r\n\r\nChecks that a given field is contained within a set of values (i.e.\r\nlike an `ENUM`).\r\n\r\n``` ruby\r\ndef validate\r\n  assert_member :state, %w{pending paid delivered}\r\nend\r\n```\r\n\r\nThe error code for this assertion is `:not_valid`\r\n\r\n### assert_length\r\n\r\nChecks that a given field's length falls under a specified range.\r\n\r\n``` ruby\r\ndef validate\r\n  assert_length :username, 3..20\r\nend\r\n```\r\n\r\nThe error code for this assertion is `:not_in_range`.\r\n\r\n### assert_decimal\r\n\r\nChecks that a given field looks like a number in the human sense\r\nof the word. Valid numbers are: 0.1, .1, 1, 1.1, 3.14159, etc.\r\n\r\nThe error code for this assertion is `:not_decimal`.\r\n\r\nInstallation\r\n------------\r\n\r\n    $ gem install scrivener\r\n","tagline":"Validation frontend for models.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}